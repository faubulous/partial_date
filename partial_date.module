<?php

use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\partial_date\DateTools;

/**
 * Implements hook_help().
 */
function partial_date_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for partial_date module.
    case 'help.page.partial_date':
      $output = '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The <i>Partial Date</i> module provides the ability to store incomplete dates (like Year & Month only). '
          . 'For more information see the <a href=":doc">online documentation</a>.',
          array(':doc' => 'https://www.drupal.org/project/partial_date')) . '</p>';
      $output .= '<h3>' . t('Uses') . '</h3>';
      $output .= '<dl>';
      $output .= '<dt>'. t('Partial date formats') . '</dt>';
      $output .= '<dd>'. t('Three formats are provided by default (<i>short</i>, <i>medium</i> & <i>long</i>). '
          . 'You may addapt them to your needs or create additional ones through <a href=":doc">configuration page</a>.',
          array(':doc' => '/admin/config/regional/partial-date-formats')) . '</dd>';
      $output .= '<dt>'. t('Estimates') . '</dt>';
      $output .= '<dd>'. t('The module allow users to enter a more readable text value, for example, "<i>The stone age </i>" or "<i>Jurrassic period </i>". '
          . 'These estimate values are optional and can be disabled.') . '</dd>';
      $output .= '<dt>'. t('Timezone') . '</dt>';
      $output .= '<dd>'. t('Currently a timezone may be available to users. However, it is for informational uses only. '
          . 'Not timezone conversion is performed. This may change in the future.') . '</dd>';
      $output .= '</dl>';
      return $output;
  }
}

/**
 * Implements hook_theme().
 */
function partial_date_theme() {
  return array(
    'partial_date_element' => array(
      'render element' => 'element',
    ),
    'partial_date_components_element' => array(
      'render element' => 'element',
    ),
//    'partial_date_range_inline_element' => array(
//      'render element' => 'element',
//      'file' => 'partial_date.theme.inc',
//    ),
//    'partial_date' => array(
//      'variables' => array('item' => NULL, 'format' => 'short', 'settings' => array()),
//    ),
//    'partial_date_range' => array(
//      'variables' => array('from' => NULL, 'to' => NULL, 'settings' => array()),
//    ),
//    'partial_date_format_settings_form' => array(
//      'render element' => 'form',
//      'file' => 'partial_date.pages.inc',
//    ),
//    'partial_date_inline_form_element' => array(
//      'render element' => 'element',
//      'file' => 'partial_date.theme.inc',
//    ),
    'checkbox_with_options' => array(
      'render element' => 'element',
    ),
  );
}


/**
 * The theme wrapper for a single date component.
 * todo: floating support.
 */
//function theme_partial_date_element($variables) {
//  $element = $variables['element'];
//  return '<div class="partial-date-element clearfix">' . drupal_render_children($element) . '</div>';
//}
//
//function theme_partial_date_range($variables) {
//  $to = $variables['to'];
//  $from = $variables['from'];
//  $settings = $variables['settings'];
//  $separator = '';
////TODO "read range separator from partial_date.format.???.separators.range:"
////  if (!empty($settings['component_settings'])
////    && !empty($settings['component_settings']['separator'])
////    && !empty($settings['component_settings']['separator']['range'])) {
////    $separator = $settings['component_settings']['separator']['range'];
////  }
//  if (!strlen($separator)) {
//    $separator = t(' to ', array(), array('context' => 'datetime'));
//  }
//  return t('@from@separator@to', array('@from' => $from, '@to' => $to, '@separator' => $separator));
//}

/**
 * TODO
 *
 * Template preprocess function to add theme suggestions for the various
 * partial date format types.
 */

/**
 * The partial date theme callback.
 *
 * Allows easy override of the format if required.
 */
function theme_partial_date($variables) {
  $item = $variables['item'];
  $settings = $variables['settings'];
  $settings['format'] = $variables['format'];
  $settings['is_approximate'] = !empty($variables['is_approximate']);
  return partial_date_format($item, $settings);
}

function partial_date_reduce_range_values(&$from, &$to) {
  // Reduce dates on granularity values.
  foreach (array_keys(partial_date_components()) as $key) {
    // Excat match as we need to compare '' to 0.
    if (!isset($from[$key]) && !isset($to[$key])) {
      continue;
    }
    elseif ((isset($from[$key]) || !isset($to[$key])) || $from[$key] !== $to[$key]) {
      break;
    }
    $from[$key] = NULL;
  }
}

################################################################################
#  ----------------------                                                      #
#  API related functions:                                                      #
#  ----------------------                                                      #
#                                                                              #
#  Note: It would be great to move these to the date_api.                      #
#                                                                              #
#  Main functions include:                                                     #
#   * partial_date_components()                                                #
#     Returns the date and time values used by the module.                     #
#     This controls almost everything, from defining the schema to controlling #
#     the output of the formatters.                                            #
#                                                                              #
#   * partial_date_day_ordinal_suffix()                                        #
#      - moved to DateTools::ordinalSufix(int $day)                            #
#                                                                              #
#   * partial_date_granularity_field_options()                                 #
#     Returns select options for various components.                           #
#                                                                              #
#   * partial_date_mktime()                                                    #
#     Returns a timestamp (int / float) based on the available components.     #
#                                                                              #
#   * partial_date_timezone_handling_correlation()                             #
#     Forces a given timezone into the specified timezone handling option.     #
#                                                                              #
#   * partial_date_timezone_option_is_selectable()                             #
#     Determines if the timezone component should be rendered.                 #
#                                                                              #
#   * partial_date_timezone_handling_options()                                 #
#     Returns an option list of supported timezone handling options.           #
#                                                                              #
#   * partial_date_year_designation_decorator()                                #
#     Returns the year with the appropriative designation added.               #
#                                                                              #
#   * partial_date_year_designation_options()                                  #
#     Returns an option list of supported year designations.                   #
#                                                                              #
#                                                                              #
#==============================================================================#
#     Moved to DateTools:                                                      #
#                                                                              #
#   * partial_date_is_leap_year()         => DateTools::isLeapYear($year)      #
#     Checks to see if the specified year is a leap year.                      #
#                                                                              #                                                                              #
#   * partial_date_month_abbreviations()  => DateTools::monthAbbreviations()   #
#     Returns an option list of month abbreviations.                           #
#                                                                              #
#   * partial_date_month_matrix()         => DateTools::monthMatrix()          #
#     Returns the valid month lengths based of the specified year.             #
#                                                                              #
################################################################################

/**
 * These are the core components that always exist, but are shown or hidden
 * depending on the selected field settings.
 */
function partial_date_components(array $excluded_components = NULL) {
  static $components = NULL;
  if (!isset($components)) {
    $components = array(
      'year' => t('Year', array(), array('context' => 'datetime')),
      'month' => t('Month', array(), array('context' => 'datetime')),
      'day' => t('Day', array(), array('context' => 'datetime')),
      'hour' => t('Hour', array(), array('context' => 'datetime')),
      'minute' => t('Minute', array(), array('context' => 'datetime')),
      'second' => t('Second', array(), array('context' => 'datetime')),
      'timezone' => t('Timezone', array(), array('context' => 'datetime')),
    );
  }
  if ($excluded_components) {
    return array_diff_key($components, array_flip($excluded_components));
  }

  return $components;
}

/**
 * Simpler version of the above with keys only (no labels).
 */
function partial_date_component_keys() {
  static $components = NULL;
  if (!isset($components)) {
    $components = array(
      'year',
      'month',
      'day',
      'hour',
      'minute',
      'second',
    );
  }
  return $components;
}

function remove_time_components(array &$components){
  unset($components['hour'], $components['minute'], $components['second'], $components['timezone']);
}
function remove_timezone(array &$components){
  unset($components['timezone']);
}
/**
 * Returns a translated array of timezone handling options.
 *
 * Currently, this is a copy of the Dates module options.
 */
function partial_date_timezone_handling_options() {
  return array(
    'none' => t('No timezone conversion'),
    'date' => t('User selectable', array(), array('context' => 'datetime')),
    'site' => t("Site's timezone"),
    'user' => t("User's account timezone"),
    'utc' => t('UTC', array(), array('context' => 'datetime')),
  );
}

/**
 * Helper function to control how and if the timezone component should be
 * rendered.
 */
function partial_date_timezone_option_is_selectable($tz_handling) {
  return ($tz_handling == 'none' || $tz_handling == 'date');
}

/**
 * Helper function to determine the correct timezone based on the timezone
 * handling options used.
 *
 * @param string $timezone
 *   Current timezone from the database or widget.
 *
 * @param string $tz_handling
 *   The timezone handling options that needs enforcing.
 */
function partial_date_timezone_handling_correlation($timezone = '', $tz_handling = 'none') {
  $user = \Drupal::currentUser();

  // Override or return unchanged depending on the set action.
  switch ($tz_handling) {
    case 'utc':
      return 'UTC';

    case 'site':
      $config = \Drupal::config('system.date');
      $default_timezone = $config->get('timezone.default');
      return !empty($default_timezone) ? $default_timezone : @date_default_timezone_get();

    case 'user':
      return drupal_get_user_timezone();

    case 'date':
    case 'none':
      // Parse the existing timezone.
      $timezone = isset($timezone) ? $timezone : '';
      switch ($timezone) {
        case '--user--':
        case '--site--':
          $timezone = partial_date_timezone_handling_correlation($timezone, trim($timezone, '-'));
          break;
      }
      return $timezone;

    default:
      return '';

  }
}

/**
 * Returns option lists for the various components, with the exception of year
 * which is not supported.
 *
 * @param string $type
 *   One of the date granularity keys: year, month, day, etc.
 * @param array $options
 *   Additional values to prefix onto the options list.
 */
function partial_date_granularity_field_options($type, $options = array(), $increment = 1) {
  switch ($type) {
    case 'second':
    case 'minute':
      $tmp = array(0, 15, 30, 45);
      return $options + array_combine($tmp, $tmp); //date_minutes('i', FALSE, $increment);

    case 'hour':
      return $options + array_combine(range(0, 23), range(0, 23));

    case 'day':
      return $options + array_combine(range(1, 31), range(1, 31));

    case 'month':
      return $options + \Drupal\partial_date\DateTools::monthNames();

    case 'timezone':
      // Ref: Date API module
      return $options; //TODO: find the proper way to display timezones.... // + date_timezone_names(TRUE);

    case 'year':
    default:
      return $options;
  }
}

/**
 * Decorates a year with the given year designations.
 *
 * As there is no year 0, so an empty year will return an empty string.
 */
function partial_date_year_designation_decorator($year, $designation = 'ce') {
  static $designation_suffixes;
  if (empty($designation_suffixes)) {
    $designation_suffixes = array(
      'BC' => 'BC',
      'AD' => 'AD',
      'BCE' => 'BCE',
      'CE' => 'CE',
    );
    foreach ($designation_suffixes as $key => $designation_suffix) {
      $designation_suffixes[$key] = t($designation_suffix, array(), array('context' => 'datetime'));
    }
  }

  if (empty($year) || !is_numeric($year)) {
    return '';
  }
  switch ($designation) {
    case 'ce':
      return $year > 0 ? $designation_suffixes['CE'] : $designation_suffixes['BCE'];

    case 'bce':
      return $year > 0 ? '' : $designation_suffixes['BCE'];

    case 'ad':
      return $year > 0 ? $designation_suffixes['AD'] : $designation_suffixes['BC'];

    case 'bc':
      return $year > 0 ? '' : $designation_suffixes['BC'];

    case 'sign':
    default:
      return '';
  }
}

/**
 * Generates a numeric date string.
 */
function partial_date_float(array $c) {
  foreach (partial_date_components(array('timezone')) as $key => $label) {
    if (!isset($c[$key]) || !strlen($c[$key])) {
      $c[$key] = 0;
    }
    elseif ($key != 'year' && $key != 'month') {
      // Increment hours, minutes and seconds to allow the module to distintish
      // between 0 meaning unset and 1 to 24/60 being the actual values.
      // Day is incremented to provide a buffer to add / remove the timezone.
      $c[$key] = $c[$key] + 1;
    }
  }

  $date = abs($c['year'])
      . sprintf('%02s', $c['month'])  // 0 or 1-12
      . sprintf('%02s', $c['day']) // 0 or 2-32
      . sprintf('%02s', $c['hour']) // 0 or 1-24
      . sprintf('%02s', $c['minute']) // 0 or 1-60
      . sprintf('%02s', $c['second']); // 0 or 1-60
  return ((float) ltrim($date, '0')) * ($c['year'] >= 0 ? 1.0 : -1.0);
}

/**
 * Creates a timestamp based on the available components.
 *
 * Copied from Zend_Date. Significantly modified.
 *
 * @param array $components
 *   An array of all the defined date components including timezone.
 *
 * @return  integer|float
 *   An approx. timestamp (number of seconds elapsed relative to 1970/01/01 00:00:00 GMT/UTC)
 */
function partial_date_mktime(array $components) {
  $components = array_intersect_key($components, partial_date_components());
  extract($components, EXTR_SKIP);

  if ((1901 < $year) and ($year < 2038)) {
    $oldzone = @date_default_timezone_get();
    if ($timezone && ($timezone != $oldzone)) {
      date_default_timezone_set($timezone);
    }
    $result = @mktime($hour, $minute, $second, $month, $day, $year);
    if ($timezone && ($timezone != $oldzone)) {
      date_default_timezone_set($oldzone);
    }
    if ($result !== FALSE) {
      return $result;
    }
  }

        // Get approx. offset
# Error in float pre 1900 probably makes this pointless
#        if ($gmt !== true) {
#          $tz = new DateTimeZone($timezone);
#          $second += $tz->getOffset(date_create('2000-01-01 00:00 GMT'));
#        }

  // date to integer
  $day   = intval($day);
  $month = intval($month);
  $year  = intval($year);
  $_monthTable = Drupal\partial_date\DateTools::monthMatrix($year);

  if ($month > 12) {
    $overlap = floor($month / 12);
    $year   += $overlap;
    $month  -= $overlap * 12;
  }
  else {
    $overlap = ceil((1 - $month) / 12);
    $year   -= $overlap;
    $month  += $overlap * 12;
  }

  $date = 0;
  // correct months > 12 and months < 1
  if ($year < -99999 || $year > 99999) {
    // Calculate the average number of seconds in a year.
    $seconds_in_year = ($year - 1970) * DateTools::SECONDS_PER_YEAR;

    $leapyear = partial_date_is_leap_year($year);
    for ($mcount = 0; $mcount < ($month - 1); $mcount++) {
      $date += $_monthTable[$mcount];
      if (($leapyear === true) and ($mcount == 1)) {
          $date++;
      }
    }
    $date += $day - 1;
    $date = (($date * 86400) + ($hour * 3600) + ($minute * 60) + $second + $seconds_in_year);
  }
  elseif ($year >= 1970) {
    // Date is after UNIX epoch
    // go through leapyears
    // add months from latest given year
    for ($count = 1970; $count <= $year; $count++) {
      $leapyear = partial_date_is_leap_year($count);
      if ($count < $year) {
        $date += 365;
        if ($leapyear === true) {
            $date++;
        }
      }
      else {
        for ($mcount = 0; $mcount < ($month - 1); $mcount++) {
          $date += $_monthTable[$mcount];
          if (($leapyear === true) and ($mcount == 1)) {
              $date++;
          }
        }
      }
    }

    $date += $day - 1;
    $date = (($date * 86400) + ($hour * 3600) + ($minute * 60) + $second);
  }
  else {
    // Date is before UNIX epoch
    // go through leapyears
    // add months from latest given year
    for ($count = 1969; $count >= $year; $count--) {
      $leapyear = partial_date_is_leap_year($count);
      if ($count > $year) {
        $date += 365;
        if ($leapyear === true) {
          $date++;
        }
      }
      else {
        for ($mcount = 11; $mcount > ($month - 1); $mcount--) {
          $date += $_monthTable[$mcount];
          if (($leapyear === true) and ($mcount == 2)) {
            $date++;
          }
        }
      }
    }

    $date += ($_monthTable[$month - 1] - $day);
    $date = -(($date * 86400) + (86400 - (($hour * 3600) + ($minute * 60) + $second)));

    // gregorian correction for 5.Oct.1582
    if ($date < -12220185600) {
        $date += 864000;
    }
    elseif ($date < -12219321600) {
        $date  = -12219321600;
    }
  }
  return $date;
}


/**
 * Function used by uasort to sort structured arrays by weight.
 */
function partial_date_sort($a, $b) {
  $a_weight = (is_array($a) && isset($a['weight'])) ? $a['weight'] : 0;
  $b_weight = (is_array($b) && isset($b['weight'])) ? $b['weight'] : 0;
  if ($a_weight == $b_weight) {
    return 0;
  }
  return ($a_weight < $b_weight) ? -1 : 1;
}

/**
 * Returns any configured separators for two components.
 */
function _partial_date_component_separator($a, $b, $separators = array()) {
  if ($a === FALSE) {
    return;
  }
  $a_type = _partial_date_component_type($a);
  $b_type = _partial_date_component_type($b);
  if (!$a_type || !$b_type) {
    $key = 'other';
  }
  elseif ($a_type == $b_type) {
    $key = $a_type;
  }
  else {
    $key = 'datetime';
  }
  return isset($separators[$key]) ? $separators[$key] : FALSE;

}
/**
 * Helper function to determine the component type for inserting the component
 * separator.
 *
 * @return mixed
 *   One of date, time or FALSE.
 */
function _partial_date_component_type($key) {
  switch ($key) {
    case 'year':
    case 'month':
    case 'day':
      return 'date';

    case 'hour':
    case 'minute':
    case 'second':
      return 'time';

    case 'timezone':
    default:
      return FALSE;
  }
}


function _partial_date_render_component($key, $item, $field, $format) {
  switch ($field) {
    case 'none':
      return '';

    case 'date_only':
      return isset($item[$key]) ? $item[$key] : '';

    case 'estimate_label':
    case 'estimate_range': // Start (single or from dates) or End (to dates) of estimate range
    case 'estimate_component': // Date component with fallback to estimate component
    case 'date_or':

    default:
      return $field;
  }
}

